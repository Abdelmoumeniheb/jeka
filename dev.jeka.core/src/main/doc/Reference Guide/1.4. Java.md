## Java Project Building

Jeka provides API for processing usual Java build tasks. To illustrate this, let's start from the following 
layout : 

```java
    Path src = getBaseDir().resolve("src/main/java");
    Path buildDir = getBaseDir().resolve("build/output");
    Path classDir = getOutputDir().resolve("classes");
    Path jarFile = getOutputDir().resolve("jar/" + getBaseTree().getRoot().getFileName() + ".jar");
    JkClasspath classpath = JkClasspath.of(getBaseTree().andAccept("libs/**/*.jar").getFiles());
    Path reportDir = buildDir.resolve("junitRreport");
```

### Compilation

`JkJavaCompiler` stands for the compiler binary or tool while `JkJavaCompileSpec` stands for what to compile and how.

```java
JkJavaCompiler.ofJdk().compile(JkJavaCompileSpec.of()
                .setOutputDir(classDir)
                .setClasspath(classpath)
                .setSourceAndTargetVersion(JkJavaVersion.V8)
                .addSources(src));
```

`JkJavaCompiler.ofJdk()` provides the compiler embedded with the JDK without forking the process. It is possible to fork 
it or choose an external compiler for cross-compile purpose.


### Javadoc

Simple Javadoc tasks can be performed using `JkJavadocMaker` class.

```java
JkJavadocMaker.of(JkPathTreeSet.of(src), buildDir.resolve("javadoc")).process();
```

### Classpath

Jeka provides `JkClasspath` to construct and reason about classpath.

```java
JkClasspath classpath = JkUrlClassLoader.ofCurrent().getFullClasspath();
Path guavaJar = classpath.getEntryContainingClass("com.google.common.base.Strings");
```
### Java jar and manifest

`JkpathTree` class help to produce simply jar files using `zipTo` method :  `JkPathTree.of(classDir).zipTo(jarFile)`

Nevertheless `JkJarPacker` along `JkManifest` provides powerful methods to read/write/edit manifests and create fat jars.

```java
JkManifest.ofEmpty().addMainClass("RunClass").writeToStandardLocation(classDir);
```

### Classloaders

`JkClassloader` provides utility methods to reason about classloaders and to invoke methods coming from class loaded 
in other classloader than the current one.

`JkUrlClassloader` provides classpath scanning functions.

### Junit tests

The following snippet shows how to launch Junit tests programmatically.
```java
   JkUnit.of().withForking()
        .withReportDir(reportDir)
        .withReport(JunitReportDetail.FULL)
        .run(classpath, JkPathTree.of(testClassDir).andAccept("**/*Test.class", "*Test.class") ));
```

### Projects

Projects are file structures for hosting Java projects meaning source code, test codes, dependencies, 
build instructions.

The principle is that each `JkJavaProject` holds everything needed to compile, test, pack and publish
artifacts. The API embrace the *parent-chaining* patten 

This is a pretty complete example taken from the Jeka build itself.
```
java.getProject()
    .getArtifactProducer()
        .putMainArtifact(this::doPackWithEmbedded)
        .putArtifact(DISTRIB_FILE_ID, this::doDistrib)
        .putArtifact(WRAPPER_ARTIFACT_ID, this::doWrapper).__ // define wrapper
    .getCompilation()
        .getLayout()
            .includeSourceDirsInResources().__
        .addOptions("-Xlint:none","-g")
        .setJavaVersion(JkJavaVersion.V8)
        .getCompiler()
            .setForkingWithJavac().__.__
    .getTesting()
        .getCompilation()
            .getLayout()
                .includeSourceDirsInResources().__
            .getCompiler()
                .setDefault().__.__
        .getTestProcessor()
            .setForkingProcess(false)
            .getEngineBehavior()
                .setProgressDisplayer(JkTestProcessor.JkProgressOutputStyle.ONE_LINE).__.__
        .getTestSelection()
            .addIncludePatterns(JkTestSelection.STANDARD_INCLUDE_PATTERN)
            .addIncludePatternsIf(runIT, JkTestSelection.IT_INCLUDE_PATTERN).__.__
    .getPackaging()
        .getManifest()
            .addMainClass("dev.jeka.core.tool.Main").__.__
    .getDocumentation()
        .getJavadocProcessor()
            .setDisplayOutput(false)
            .addOptions("-notimestamp").__.__
    .getPublication()
        .setModuleId("dev.jeka:jeka-core")
        .setVersionSupplier(git::getJkVersionFromTags)
        .setRepos(JkRepoSet.ofOssrhSnapshotAndRelease(ossrhUser, ossrhPwd))
        .getPublishedPomMetadata()
            .getProjectInfo()
                .setName("jeka")
                .setUrl("https://jeka.dev")
                .setDescription("Automate with plain Java code and nothing else.").__
            .getScm()
                .setUrl("https://github.com/jerkar/jeka.git").__
            .addApache2License()
            .addGithubDeveloper("djeang", "djeangdev@yahoo.fr").__
        .getPostActions()
            .append(() -> createGithubRelease());
```

This is another example of 3 projects depending on each other.
```java
   JkVersionProvider versionProvider = JkVersionProvider.of()
                   .and("com.google.guava:guava", "21.0")
                   .and("junit:junit", "4.12");
   
           JkJavaProject fooProject = JkJavaProject.of()
               .setBaseDir(this.getBaseDir().resolve("foo"))
               .getDependencyManagement()
                   .addDependencies(JkDependencySet.of()
                       .and("junit:junit", JkJavaDepScopes.TEST)
                       .and("com.google.guava:guava")
                       .and("com.sun.jersey:jersey-server:1.19.4")
                       .withVersionProvider(versionProvider)).__;
   
           JkJavaProject barProject = JkJavaProject.of()
               .setBaseDir(this.getBaseDir().resolve("bar"))
               .getDependencyManagement().addDependencies(JkDependencySet.of()
                   .and("junit:junit", JkJavaDepScopes.TEST)
                   .and("com.sun.jersey:jersey-server:1.19.4")
                   .and(fooProject.toDependency())).__;
   
           barProject.getArtifactProducer()
               .putMainArtifact(barProject.getPackaging()::createFatJar) // Produced jar will embed dependencies
               .makeAllArtifacts();
```

You can define your onw specific artifact (distrib, binary specific,...). When defined, this artifact will be built and 
deployed along the other ones.

JkJavaProject instances are highly configurable. You can tune your project structure/build without limits.
