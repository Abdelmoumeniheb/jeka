package dev.jeka.core.api.java.junit;

import java.io.File;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URLClassLoader;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicReference;

import dev.jeka.core.api.file.JkPathTree;
import dev.jeka.core.api.file.JkPathTreeSet;
import dev.jeka.core.api.java.JkClassLoader;
import dev.jeka.core.api.java.JkClasspath;
import dev.jeka.core.api.java.JkJavaProcess;
import dev.jeka.core.api.java.JkUrlClassLoader;
import dev.jeka.core.api.system.JkException;
import dev.jeka.core.api.system.JkLog;
import dev.jeka.core.api.utils.JkUtilsIO;
import dev.jeka.core.api.utils.JkUtilsIterable;
import dev.jeka.core.api.utils.JkUtilsReflect;
import dev.jeka.core.api.utils.JkUtilsString;

/**
 * Convenient class to run Junit tests.
 *
 * @author Jerome Angibaud
 */
public final class JkUnit {

    /**
     * Detail level for the junit report.
     */
    public enum JunitReportDetail {

        /** No report at all */
        NONE,

        /** Only detail abut the failed test and overall statistics */
        BASIC,

        /** Complete report as the ones generated by surefire.*/
        FULL
    }

    private static final String JUNIT4_RUNNER_CLASS_NAME = "org.junit.runner.JUnitCore";

    private static final String JUNIT3_RUNNER_CLASS_NAME = "junit.textui.TestRunner";

    private static final String JUNIT4_TEST_ANNOTATION_CLASS_NAME = "org.junit.Test";

    private static final String JUNIT3_TEST_CASE_CLASS_NAME = "junit.framework.TestCase";

    private static final String JUNIT3_TEST_SUITE_CLASS_NAME = "junit.framework.TestSuite";

    private static final String JUNIT3_TEST_RESULT_CLASS_NAME = "junit.framework.TestResult";

    private final JunitReportDetail reportDetail;

    private final Path reportDir;

    private final JkJavaProcess forkedProcess;

    private final List<Runnable> postActions;

    private final boolean breakOnFailure;

    private final boolean printOutputOnConsole;

    private JkUnit(JunitReportDetail reportDetail, Path reportDir,
            JkJavaProcess fork, List<Runnable> runnables,
            boolean crashOnFailed, boolean printOutputOnConsole) {
        this.reportDetail = reportDetail;
        this.reportDir = reportDir;
        this.forkedProcess = fork;
        this.postActions = Collections.unmodifiableList(runnables);
        this.breakOnFailure = crashOnFailed;
        this.printOutputOnConsole = printOutputOnConsole;
    }

    @SuppressWarnings("unchecked")
    private JkUnit(JunitReportDetail reportDetail, Path reportDir,
            JkJavaProcess fork, boolean crashOnFailed,
            boolean printOutputOnConsole) {
        this(reportDetail, reportDir, fork, Collections.EMPTY_LIST,
                crashOnFailed, printOutputOnConsole);
    }

    /**
     * Returns an empty junit launcher launcher without classpath set on.
     */
    public static JkUnit of() {
        return new JkUnit(JunitReportDetail.NONE, null, null,
                true, true);
    }

    /**
     * Returns a copy of this launcher but with the specified report detail.
     */
    public JkUnit withReport(JunitReportDetail reportDetail) {
        return new JkUnit(reportDetail, reportDir, this.forkedProcess,
                this.breakOnFailure, this.printOutputOnConsole);
    }

    /**
     * Returns a copy of this launcher but with the specified report directory output.
     */
    public JkUnit withReportDir(Path reportDir) {
        return new JkUnit(reportDetail, reportDir, this.forkedProcess,
                this.breakOnFailure, this.printOutputOnConsole);
    }

    /**
     * Returns a copy of this launcher but that fail fast on the first failure.
     */
    public JkUnit withBreakOnFailure(boolean crashOnFailure) {
        return new JkUnit(reportDetail, reportDir, this.forkedProcess,
                crashOnFailure, this.printOutputOnConsole);
    }

    /**
     * Returns a copy of this launcher but specifying an action to run at the end of execution.
     */
    public JkUnit withPostAction(Runnable runnable) {
        final List<Runnable> list = new LinkedList<>(this.postActions);
        list.add(runnable);
        return new JkUnit(reportDetail, reportDir, forkedProcess, list,
                this.breakOnFailure, this.printOutputOnConsole);
    }

    /**
     * Creates a withForking JkUnit from this one but using the specified process. If
     * <code>appendClasspath</code> is <code>true</code> then the classpath
     * already defined in this object is appended to the specified process
     * classpath.
     */
    public JkUnit withForking(JkJavaProcess process) {
        return new JkUnit(reportDetail, reportDir, process, this.breakOnFailure, this.printOutputOnConsole);
    }

    /**
     * Creates an identical JkUnit to this one but specifying the withForking mode.
     * If the withForking mode is <code>true<code> then the specified
     * {@link JkJavaProcess} is used to run the tests..
     */
    private JkUnit withForking(boolean fork, JkJavaProcess process) {
        if (fork && !isForked()) {
            return withForking(process);
        }
        if (!fork && isForked()) {
            return new JkUnit(reportDetail, reportDir, null,
                    this.breakOnFailure, this.printOutputOnConsole);
        }
        return this;
    }

    public JkUnit withForking(Path workingDir) {
        if (isForked()) {
            return withForking(forkedProcess.withWorkingDir(workingDir));
        }
        return withForking(JkJavaProcess.of().withWorkingDir(workingDir));
    }

    /**
     * Short-hand to #withForking(true)
     */
    public JkUnit withForking() {
        return withForking(true);
    }

    /**
     * Creates an identical JkUnit to this one but specifying the withForking mode.
     * If the withForking mode is <code>true<code> then default {@link JkJavaProcess}
     * is used to run the tests (java process launched without any option).
     */
    public JkUnit withForking(boolean fork) {
        return withForking(fork, JkJavaProcess.of());
    }

    /**
     * Returns an enhanced copy of this launcher but specifying if the output should be displayed on console.
     */
    public JkUnit withOutputOnConsole(boolean outputOnConsole) {
        return new JkUnit(reportDetail, reportDir, forkedProcess, breakOnFailure, outputOnConsole);
    }

    /**
     * Returns <code>true</code> if this launcher is withForking.
     */
    public boolean isForked() {
        return this.forkedProcess != null;
    }

    /**
     * Returns the report detail level for this launcher.
     */
    public JunitReportDetail getReportDetail() {
        return reportDetail;
    }

    /**
     * Returns the output report dir.
     */
    public Path getReportDir() {
        return reportDir;
    }

    /**
     * Returns the process description if this launcher is withForking.
     */
    public JkJavaProcess getForkedProcess() {
        return forkedProcess;
    }

    /**
     * Runs specified test bulk.
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public JkTestSuiteResult run(JkJavaTestClasses testSpec) {
        if (reportDir == null && reportDetail != JunitReportDetail.NONE) {
            throw new IllegalStateException("Report directory has not been set on JkUnit instance.");
        }
        final Collection<Class> classes = getClassesToTest(testSpec);
        final String name = getSuiteName(classes);

        if (!classes.iterator().hasNext()) {
            JkLog.warn("No test class found on " + testSpec.getClassesToTest());
            return JkTestSuiteResult.ofEmpty((Properties) System.getProperties().clone(), name, 0);
        }
        final long start = System.nanoTime();
        final JkClassLoader classLoader = JkClassLoader.ofLoaderOf(classes.iterator().next());
        final AtomicReference<JkTestSuiteResult> result = new AtomicReference<>();
        Runnable task = () -> {
            if (classLoader.isDefined(JUNIT4_RUNNER_CLASS_NAME)) {
                File report = reportDir == null ? null : reportDir.toFile();
                if (this.forkedProcess != null) {
                    JkLog.info("Test are executed in withForking mode");
                    JkClasspath classpath = testSpec.getClasspath();
                    result.set(JUnit4TestLauncher.launchInFork(forkedProcess.withClasspath(classpath),
                            printOutputOnConsole, reportDetail, classes, report));
                } else {
                    result.set(JUnit4TestLauncher.launchInProcess(classes, printOutputOnConsole,
                            reportDetail, report));
                }
            } else if (classLoader.isDefined(JUNIT3_RUNNER_CLASS_NAME)) {
                final Object suite = createJunit3TestSuite(classLoader, classes);
                final Class testResultClass = classLoader.load(JUNIT3_TEST_RESULT_CLASS_NAME);
                final Object testResult = JkUtilsReflect.newInstance(testResultClass);
                final Method runMethod = JkUtilsReflect.getMethod(suite.getClass(), "run",
                        testResultClass);
                final Properties properties = (Properties) System.getProperties().clone();
                JkUtilsReflect.invoke(suite, runMethod, testResult);
                final long end = System.nanoTime();
                final long duration = (end - start) / 1000000;
                result.set(fromJunit3Result(properties, name, testResult, duration));
            } else {
                JkUtilsIO.closeifClosable(classLoader.getDelegate());
                throw new JkException("No Junit found on test classpath.");
            }

            if (result.get().getFailureCount() > 0) {
                if (breakOnFailure) {
                    JkLog.error(String.join("\n",
                            result.get().toStrings(JkLog.Verbosity.VERBOSE == JkLog.verbosity())));
                    JkUtilsIO.closeifClosable(classLoader.getDelegate());
                    throw new JkException("Test failed : " + result.toString());
                } else {
                    JkLog.warn(String.join("\n",
                            result.get().toStrings(JkLog.Verbosity.VERBOSE == JkLog.verbosity())));
                }
            } else {
                JkLog.info(String.join("/n",
                        result.get().toStrings(JkLog.Verbosity.VERBOSE == JkLog.verbosity())));
            }
            if (JkLog.Verbosity.VERBOSE != JkLog.verbosity() && result.get().getFailureCount() > 0) {
                JkLog.info("Launch Jeka in verbose mode to display failure stack traces andAccept console.");
            }
            if (reportDetail.equals(JunitReportDetail.BASIC)) {
                TestReportBuilder.of(result.get()).writeToFileSystem(reportDir);
            }
            for (final Runnable runnable : this.postActions) {
                runnable.run();
            }
        };
        JkLog.execute("Executing JUnit tests", task);
        JkUtilsIO.closeifClosable(classLoader.getDelegate());
        return result.get();
    }

    public JkTestSuiteResult run(JkClasspath classpath, JkPathTreeSet classesToTest) {
        return run(JkJavaTestClasses.of(classpath, classesToTest));
    }

    public JkTestSuiteResult run(JkClasspath classpath, JkPathTree classesToTest) {
        return run(JkJavaTestClasses.of(classpath, classesToTest));
    }

    @SuppressWarnings("rawtypes")
    private Collection<Class> getClassesToTest(JkJavaTestClasses testSpec) {
        final JkClasspath classpath = testSpec.getClasspath().andPrepending(testSpec.getClassesToTest().getRootDirsOrZipFiles());
        final JkUrlClassLoader classLoader = JkUrlClassLoader.of(classpath, ClassLoader.getSystemClassLoader().getParent());
        classLoader.loadAllServices();
        final Collection<Class> result = getJunitTestClassesInClassLoader(classLoader, testSpec.getClassesToTest());
        if (result.isEmpty()) {
            JkUtilsIO.closeifClosable(classLoader.getDelegate());
        }
        return result;
    }

    @SuppressWarnings("rawtypes")
    private static Collection<Class> getJunitTestClassesInClassLoader(JkUrlClassLoader classloader,
                                                                      JkPathTreeSet jkPathTreeSet) {
        final Iterable<Class<?>> classes = classloader.loadClassesIn(jkPathTreeSet);
        final List<Class> testClasses = new LinkedList<>();
        if (classloader.toJkClassLoader().isDefined(JUNIT4_RUNNER_CLASS_NAME)) {
            final Class<Annotation> testAnnotation = classloader
                    .toJkClassLoader().load(JUNIT4_TEST_ANNOTATION_CLASS_NAME);
            final Class<?> testCaseClass = classloader.toJkClassLoader().load(JUNIT3_TEST_CASE_CLASS_NAME);
            for (final Class clazz : classes) {
                if (isJunit3Test(clazz, testCaseClass) || isJunit4Test(clazz, testAnnotation)) {
                    testClasses.add(clazz);
                }
            }
        } else if (classloader.toJkClassLoader().isDefined(JUNIT3_RUNNER_CLASS_NAME)) {
            final Class<?> testCaseClass = classloader.toJkClassLoader().load(JUNIT3_TEST_CASE_CLASS_NAME);
            for (final Class clazz : classes) {
                if (isJunit3Test(clazz, testCaseClass)) {
                    testClasses.add(clazz);
                }
            }
        }
        return testClasses;
    }

    private static boolean isJunit3Test(Class<?> candidtateClazz, Class<?> testCaseClass) {
        if (Modifier.isAbstract(candidtateClazz.getModifiers())) {
            return false;
        }
        return testCaseClass.isAssignableFrom(candidtateClazz);
    }

    private static boolean isJunit4Test(Class<?> candidateClass, Class<Annotation> testAnnotation) {
        if (Modifier.isAbstract(candidateClass.getModifiers())) {
            return false;
        }
        return hasConcreteTestMethods(candidateClass, testAnnotation);
    }

    private static boolean hasConcreteTestMethods(Class<?> candidateClass,
            Class<Annotation> testAnnotation) {
        for (final Method method : candidateClass.getMethods()) {
            final int modifiers = method.getModifiers();
            if (!Modifier.isAbstract(modifiers) && Modifier.isPublic(modifiers)
                    && method.getAnnotation(testAnnotation) != null) {
                return true;
            }
        }
        return false;
    }

    @SuppressWarnings("rawtypes")
    private static Object createJunit3TestSuite(JkClassLoader classLoader,
                                                Iterable<Class> testClasses) {
        final Class<?>[] classArray = JkUtilsIterable.arrayOf(testClasses, Class.class);
        final Class<?> testSuiteClass = classLoader.load(JUNIT3_TEST_SUITE_CLASS_NAME);
        try {
            final Constructor constructor = testSuiteClass.getConstructor(classArray.getClass());
            return constructor.newInstance((Object) classArray);
        } catch (final Exception e) {
            throw new IllegalStateException(e);
        }
    }

    private static JkTestSuiteResult fromJunit3Result(Properties properties, String suiteName,
            Object result, long durationInMillis) {
        final Integer runCount = JkUtilsReflect.invoke(result, "runCount");
        final Integer ignoreCount = 0;
        final Enumeration<Object> junitFailures = JkUtilsReflect.invoke(result, "failures");
        final Enumeration<Object> junitErrors = JkUtilsReflect.invoke(result, "errors");
        final List<JkTestSuiteResult.JkTestCaseFailure> failures = new ArrayList<>();
        while (junitFailures.hasMoreElements()) {
            final Object junitFailure = junitFailures.nextElement();
            failures.add(JkTestSuiteResult.fromJunit3Failure(junitFailure));
        }
        while (junitErrors.hasMoreElements()) {
            final Object junitError = junitErrors.nextElement();
            failures.add(JkTestSuiteResult.fromJunit3Failure(junitError));
        }
        return new JkTestSuiteResult(properties, suiteName, runCount, ignoreCount, failures,
                durationInMillis);

    }

    @SuppressWarnings("rawtypes")
    private static String getSuiteName(Iterable<Class> classes) {
        final Iterator<Class> it = classes.iterator();
        if (!it.hasNext()) {
            return "";
        }
        final Class<?> firstClass = it.next();
        if (!it.hasNext()) {
            return firstClass.getName();
        }
        String[] result = firstClass.getPackage().getName().split("\\.");
        while (it.hasNext()) {
            final String[] packageName = it.next().getPackage().getName().split("\\.");
            final int min = Math.min(result.length, packageName.length);
            for (int i = 0; i < min; i++) {
                if (!result[i].equals(packageName[i])) {
                    if (i == 0) {
                        return "ALL";
                    }
                    result = Arrays.copyOf(result, i);
                    break;
                }
            }
        }
        return JkUtilsString.join(Arrays.asList(result), ".");
    }

}
