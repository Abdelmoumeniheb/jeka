# Welcome to Jeka

### Jeka directory content 

By convention, every project automated or built by Jeka contains a _jeka_ directory at its root (_[Project Root]/jeka_). 
This directory contains everything Jeka needs to automate or build this project.

In this directory, you may find :
  * __def__ (directory - optional) : This is where lie your Java and/or Kotlin sources that will be executed by the automation engine.
  * __output__ (directory - generated) : Files produced by the build (jar, classes, reports, ...) are supposed to be generated here.
  * __boot__ (directory - optional) : All jars located here are added to the build classpath and can therefore be used by the classes defined in *def*.
  * __wrapper__ (directory - optional) : Contains the wrapper jar file for bootstrapping Jeka along its configuration.
  * __.work__ (directory - generated): temp files generated by Jeka internal engine are located here. Sources from _def_ are compiled here.
  * __options.properties__ (file - optional) : May contains configuration default defined at project level.
  * __cmd.properties__ (file - optional) : May contains predefined command shortcuts that can be invoked with a single keyword.

Depending on your needs, feel free to store any build related elements in this directory.

Besides, project root may also contain _jekaw_ and _jekaw.bat_ shell scripts to invoke jeka wrapper conveniently.

For the following, when we refer to the command `jeka`, you can use `./jekaw` indifferently.
All command line are supposed to be launched from the root of the project (and not from _[Project Root]/jeka_).

### What is Jeka wrapper

Jeka wrapper consists in shell scripts, a booting jar and a configuration file in order Jeka can be executed on a specified 
version without being installed on the host machine. This is the recommended way of using Jeka as it makes your builds 
portable from one machine to another.

* __jekaw__ and __jekaw.bat__ are respectively _Unix like_ and _Windows_ scripts to launch bootstrapping jar.
* __jeka/wrapper/dev.jeka.core-wrapper.jar__ is the bootable jar in charge of downloading and installing the specified Jeka 
  version on the host machine prior to launch _Jeka_
* __jeka/wrapper/wrapper.properties__ specifies the Jeka version to use.

### What is inside _[User Home]/.jeka_

_Jeka_ automatically creates a directory  _[User Home]/.jeka_ when running for the first time. This directory may contain
* __options.properties__ (file - optional) : Contains options defined at user level (see later section).
* __cache__ (directory - generated) : Contains various files cached by Jeka as downloaded dependencies, downloaded Jeka versions, ... This directory can be safely deleted.
* __maven_publish_dir__ (directory - generated) : Contains artifacts that your projects have published locally respecting Maven repository standards
* __ivy_publish_dir__ (directory - generated) : Contains artifacts that your projects have published locally respecting Ivy repository standards

In the contrary of Maven, _Jeka_ does not publish locally on the same repository where are downloaded artifacts.

### Write a simple build class and invoke it

Prior to writing a build class, you must import your project in your IDE with proper dependencies declared on.
* Add an IDE _path variable_ ***JEKA_USER_HOME*** pointing on _[USER HOME]/.jeka_. In _Intellij_ :  **Settings... | Appearance & Behavior | Path Variables**
* If you use `jeka` instead of `jekaw`, add an IDE _path variable_ ***JEKA_HOME*** pointing on your local installation of _Jeka_.
* Execute `jeka intellij#iml` or `jeka eclipse#files` in order to generate metadata. 
* Attach the project to your Ide

Now you can create some Java or Kotlin classes in the _def_ directory.
* Create a class extending `JkClass`.
* Create a public method inside returning `void` and taking no parameters. Implementing with whatever you want (It can be a simple _hello world or complex release pipeline).
* Execute `jeka yourMethodName` on console at root of you project. It runs !
* Annotate it with `@JkDoc` mentioning the purpose of this method.
* Execute `jeka help`. It is now mentioned on help output.
* You can invoke several methods in a single command.
* You can have many classes extending _JkClass_ in your _def_ directory. In this case, you must specify witch class you want to run adding option `-JKC=[YourClassName]` to command line.
* If you want a class in _def_ not to be compiled, name it with a leading '_'.

#### Adding some parameters

* In your build class, declare a public field of a simple type (String, boolean, int, float, enum, date, composite objects of simple types).
* You can declare this field with a default value (e.g. `public int yourFieldName = 3;`).
* Make your methods use this field.
* Execute `jeka yourMethodName -yourFiedName=5`. The value is cast in declared type.
* Annotate this field with `@JkDoc` mentioning its purpose.
* Execute `jeka help`. It is now mentioned on help output.
* Create another public field, and annotate id with `@JkEnv` mentioning the name of an environment variable. 
* You can now use this environment variable cast to the desired type in your build classes (of course, you can also document it using `@JkDoc`).
* For more details about accepted types, see `dev.jeka.core.tool.FieldInjector#parse` method.
* For example about composite objects, see example in `dev.jeka.core.tool.builtins.project.JkPluginProject#pack` field.

#### Using 3rd party dependencies in your builds

Jeka embeds a bunch of utilities to perform build related tasks (file/zip manipulation, git, launching processes, compilation, testing, dependency management, crypto, ...) 
nevertheless, you may want rightfully to use some 3rd-party dependencies.

* One way is to add directly jar files to _jeka/boot_ directory.
  * Add jar files to _jeka/boot_ directory.
  * Execute `jeka intellij#iml` or `jeka eclipse#files`.
  * Now, you can use added libraries in your code.
* Another way is to annotate your build class with `@JkDefClasspath` mentioning either a module coordinate (e.g. _org.seleniumhq.selenium:selenium-remote-driver:4.0.0_) or a path on the local file system.
  * Annotate your build class as mentioned.
  * Execute `jeka intellij#iml` or `jeka eclipse#files`.
  * Now, you can use declared libraries along their dependencies in your code.
  * Be aware that a dependencies imported via `@JkDefClasspath` annotation is imported for all build classes and not only for annotated class.
* The last way is to add it at execution time by mentioning either a module coordinate or a file path in the command line using '@' as in `@my.org:a-jeka-plugin:1.0.0`.
  This is a powerful way as you can activate a plugin on a project without mentioning it in the build. 
  For example [Jacoco Plugin](https://github.com/jerkar/jacoco-plugin) can be applied on builds _a posteriori_, 
  without having to change anything on the build.    

#### Importing Build Classes from other Projects

In multi-module projects, it's quite common that a build class access to a build instance coming from another module. 
You can achieve it in a statically typed way.

* In your build class, declare a field of type `JkClass` (e.g. Â´JkClass importedBuild;`). It doesn't have to be public.
* Annotate it with `@JkDefImport` mentioning the relative path of the imported project (e.g. `@JkDefImport("../anotherModule")).
* Execute `jeka intellij#iml` or `jeka eclipse#files`.
* Refine the declared type from `JkClass` to the concrete type of imported build class (the imported build class should extends `JkClass`).
* Now, you can access the imported build class in a static typed way.
* The imported build classes can also be accessed globally using `JkClass#getImportedJkClass` method. See example [here](https://github.com/jerkar/jeka/blob/master/dev.jeka.master/jeka/def/MasterBuild.java).
* Be careful that the imported build class deals with file paths using `JkClass#getBaseDir` method in order it can be safely executed from any working directory.

#### Launch and Debug from the IDE

There's 2 ways of launching or debugging _Jeka_ builds from IDE. We don't mention here, usage of [Intellij plugin](https://github.com/jerkar/jeka-ide-intellij).

##### Create a `main` Method inside your _def_ Classes

Create one or many main methods as :
```
 public static void main(String[] args) {
        JkInit.instanceOf(CoreBuild.class, args).cleanPack();
    }

    public static class Release {
        public static void main(String[] args) {
            JkInit.instanceOf(MasterBuild.class, args, "-runIT").release();
        }
    }
```
Build classes (inheriting `JkClass`) must be instantiated using `JkInit#instanceOf` in order it be setup in proper state.

The arguments passed in `main` method are interpreted as command line arguments.

Launching or debugging this way is performant as all build classes and their dependencies are already on classpath. Therefore, no compilation or dependency resolution is needed.

Be careful to launch the _main_ method using _module dir_ as _working dir_. On _IntelliJ_, this is not the default (it uses _project dir_).

To change _intelliJ_ defaults, follow : *Edit Configurations | Edit configuration templates... |  Application | Working Directory : $MODULE_DIR$*.

##### ... Or Configure an IDE Launcher 

Sometimes, you may need to mimic closer the command line behavior, for debugging purpose or to pass '@' arguments.

* Create an IDE launcher for a Java Application
* Set `dev.jeka.tool.Main` as Java main class.
* Set the same command line arguments as you would do for invoking from command line (Do not include _jeka_ command).

### Using Plugins

Plugins are similar to build class, meaning they leverage the same mechanism to provide invokable methods, injectable 
fields and auto documentation help.

The differences are :
* They extend `JkPlugin` instead of `JkClass`
* The plugin classes must be named `JkPlugin[PluginName]` where _pluginName_ is the name of the plugin (e.g. `JkPluginJacoco` is the class of plugin _jacoco_). 

Plugins are invokable from command line using a syntax as `jeka yourPluginName#aPluginField=3 yourPluginName#aMethod`.

The special thing about plugins is that their instances are bound to a single a  _build class_ instance with a bi-directional 1<->1 association. 


This means that :
* A _build class_ can be bound to several plugin instances, but not of the same class. `JkClass#getPlugins` method let a _build class_ instance access to its bound plugins by their name or class.
*  

 

### Understanding the whole process

1. _Jeka_ determines if the build class to instantiate imports build class from other project by scanning source code contained in `@JkDefImport`. 
   If so, This process is first executed on each imported projects, recursively.
2. The current classpath is augmented with the result of imported projects (compiled build classes + dependencies).
3. _Jeka_ augments classpath with scanned source code contained in `@JkDefClasspath` annotations and command line argument starting by '@'.
4. _Jeka_ evaluates if compilation is necessary : if the build class to execute or compiled build class are up-to-date, no compilation occurs.
5. _jeka_ augments the classpath with compiled classes

Once done, Jeka can instantiate the build class using the computed classpath above. For this, Jeka use the `JkInit#instanceOf` method. This method does :
1. Create a build instance invoking no-arg constructor. 
2. Identify plugins to bind to JkClass instance according command line arguments
3. Inject options in public fields of JkClass instance and bound plugins
4. Invoke `JkPlugin#beforeSetup` on bound plugin instances.
5. Invoke `JkClass#setup` on build instance.
6. Invoke `JkPlugin#afterSetup` on plugin instances.
7. Invoke `JkClass#postSetup` on build instance.

Methods of build instance are then ready to be invoked.

When writing build class, according what is your needs, you can set your init code in constructor, `#setup` or `#postSetup`.

When writing plugins, according what is your intents, you can set your init code in constructor, `#beforeSetup` or `postSetup`. 

### Useful commands 

_Jeka_ comes with predefined methods coming either from `JkClass` or built-in plugins. 

* `jeka help` : Displays on console methods and options invokable from command line, along plugins available in the classpath.
* `jeka [pugin-name]#help` : Displays on consoles all methods and option invokable for the specified plugin (e.g. `jeka scaffold#help`).
* `jeka intellij#iml` : Generates iml file for Intellij. It is generated according the dependencies declared for this project.
* `jeka intellij#iml -JKC=` : If the above fails cause your def classes do not compile, using `-JKC=` avoids def compilation phase.
* `jeka eclipse#files` : Same purpose as above to generate metadata files for Eclipse.
* `jeka scaffold#run` : Generates files for creating a basic Jeka project from scratch.
* `jeka scaffold#wrap` : Generates wrapper files (jekaw/jekaw.bat and bootstrap jar)
* `jeka scaffold#run java#` : Generate files for creating a Jeka project for building a JVM language project

### Useful standard options

You can add these options to you command line.

* `-JKC=[ClassName]` : By default, Jeka instantiates the first class found under _def_ directory to execute methods on. 
  You can force to instantiate a specific class by passing its long or short name. 
  If the class is already in classpath, then no _def_ compilation occurs.
  Using simply `-JKC=` is equivalent to `-JKC=JkClass` which is the base class bundled in Jeka.
* `-LRI` : Displays runtime info. This will display on console meaningfull information about current Jeka version, Java version, base directory, download repository, classpath, ...
* `-LSU` : Shows logs about jeka setup (compilation of def classes, plugin loading, ...).These informations are not logged by default.
* `-LS=BRACE` : Alters console output by delimiting tasks with braces and mentioning the processing time for each.
* `-LS=DEBUG` : Alters console output by showing the class name and line number from where the log has been emitted.
* `-LV` : Alters console output by displaying trace logs (emitted by `JkLog#trace`)
* `-FC` : Force compilation of _def_ classes, even if they are marked as up-to-date.

### How to change the JDK that will run _Jeka_

To determine the JDK to run upon, _jeka_ looks in priority order at :
* _JEKA_JDK_ environment variable ([_JEKA_JDK_]/bin/java must point on _java_ executable)
* _JAVA_HOME_ environment variable 

If none of these variables are present, _jeka_ will run upon the _java_ executable accessible from your _PATH_ environment.

### How to change the repository _Jeka_ uses to fetch dependencies 

By default, _jeka_ fetch dependencies from maven central (https://repo.maven.apache.org/maven2).

You can select another default repository by setting the `jeka.repos.download.url` options. 
We recommend storing this value in your [USER DIR]/.jeka/options.properties file to be reused across projects.

For more details, see `JkRepoFromOptions` javadoc.

### How to pass options

Options are pairs of String  _key-value_ that are used accros Jeka system. It typically carries log behavior, repository definition, 
tool location or version. You can define your own where using field is less appropriate.

Options can be defined at 3 different level, each taking precedence on the former one : 
* User level : Defined in [User Home]/.jeka/options.properties file. It is typically used to define repository locations 
and JDK paths.
* Project level : Defined in [Project Root]/jeka/options.properties. Store here, tool versions as `jeka.kotlin.version=1.5.21`.
* Execution level : Defined in the command line as `-optionName=value`. Generally used to specify log setting or override 
  options defined above.

The option values can be retrieved programmatically using `JkOptions#get*` static methods.


### Bundled Utilities

TODO

### Examples

TODO
