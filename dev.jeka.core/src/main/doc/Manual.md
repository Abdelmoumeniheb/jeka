# Welcome to Jeka

Jeka is a general-purpose build tool designed as a library. In other words, users describe programmatically 
the actions needed to achieve automation tasks, as they would do for regular code.

The library is designed to make complex common tasks as compiling, testing or resolving dependencies as concise as possible,
so building projects may require less typing compare to other tools you may know, with simplicity and transparency as 
a bonus.

_Jeka_ automation code can be run indifferently from IDE (via classic `main` method) or command line, thanks 
to a bundled lean and fast execution engine. This engine comes with a small set of concepts promoting simplicity,
flexibility and re-usability.

## Execution engine

### Jeka directory content 

By convention, every project automated or built by Jeka contains a _jeka_ directory at its root (_[Project Root]/jeka_). 
This directory contains everything _Jeka_ needs to automate or build the project.

In this directory, you may find :
  * __def__ (directory - optional) : User _Java_ and/or _Kotlin_ sources that will be executed by the execution engine.
  * __output__ (directory - generated) : Files produced by the tasks (jar files, classes, test reports, doc, ...)
  * __boot__ (directory - optional) : 3rd-party jar files users may add to be used by code located in *def*.
  * __wrapper__ (directory - optional) : Wrapper jar file for bootstrapping a specified version of Jeka.
  * __.work__ (directory - generated): Temp files generated by Jeka execution engine as compiled classes from _def_.
  * __options.properties__ (file - optional) : Contains properties defined at project level.
  * __cmd.properties__ (file - optional) : Contains predefined command shortcuts that can be invoked with a single keyword.

Depending on your needs, feel free to store any build related elements in this directory (keys, document templates,...).

Besides, project root may also contains _jekaw_ and _jekaw.bat_ shell scripts to invoke _Jeka_ wrapper conveniently.

For the following, when we refer to the command `jeka`, you can use `./jekaw` indifferently.
All command lines are supposed to be launched from the root of the project (and not from _[Project Root]/jeka_).

### What is Jeka wrapper

Jeka wrapper consists in shell scripts, a thin booting jar and a configuration file in order _Jeka_ can be executed on a specified 
version without being installed on the host machine. This is the recommended way of using _Jeka_ as it makes  builds 
portable from one machine to another.

* __jekaw__ and __jekaw.bat__ are respectively _Unix like_ and _Windows_ scripts to launch bootstrapping jar.
* __jeka/wrapper/dev.jeka.core-wrapper.jar__ is the bootable jar in charge of downloading and installing the specified Jeka 
  version on the host machine prior to launch _Jeka_
* __jeka/wrapper/wrapper.properties__ specifies the _Jeka_ version to use.

### What is inside _[User Home]/.jeka_

_Jeka_ automatically creates a directory  _[User Home]/.jeka_ when running for the first time. This directory may contain
* __options.properties__ (file - optional) : Properties defined at global level (see later section).
* __cache__ (directory - generated) : Various files cached by Jeka as downloaded files and specifically dependency artifacts. This directory can be safely deleted.
* __maven_publish_dir__ (directory - generated) : Contains artifacts that your projects have published locally respecting Maven repository standards
* __ivy_publish_dir__ (directory - generated) : Contains artifacts that your projects have published locally respecting Ivy repository standards

In the contrary of Maven, _Jeka_ does not publish locally on the same repository where are downloaded dependency artifacts.

### Setup _Jeka_

__Note :__ _Jeka_ organization provides a [plugin](https://plugins.jetbrains.com/plugin/13489-jeka/) to make the following
tasks smoother or transparent. Here, we'll focus only on how to do it using command line.

__Prerequisite :__ You need a JDK 8 or higher installed on your machine. By default, _Jeka_ will use the _Java_ executable 
found in your _PATH_ environment variable. See later sections for changing this default.

There is two ways of using _jeka_ : by installing _Jeka_ itself of by using a template project containing the _Jeka_ wrapper.

#### Install _Jeka_

* Download the latest release from [here](https://search.maven.org/search?q=g:%22dev.jeka%22%20AND%20a:%22jeka-core%22)
  and unpack the _distrib.zip_ wherever you want on your machine. We'll refer to this directory as [JEKA HOME].
* Add [JEKA HOME] to your _PATH_ environment variable.
* Now, you can now use `jeka` command from everywhere.

#### Or use a Template Wrapper Project

* Clone template blank project from https://github.com/jerkar/blank-template-project.git
* Now, you can use `jekaw` command from your local directory.

#### Setup IDE

* Add an IDE _path variable_ ***JEKA_USER_HOME*** pointing on _[USER HOME]/.jeka_. In _Intellij_ :  **Settings... | Appearance & Behavior | Path Variables**
* If you use `jeka` instead of `jekaw`, add an IDE _path variable_ ***JEKA_HOME*** pointing on [JEKA HOME].

### Basic Project 

In first instance, we'll focus on how execution engine works. For simplicity's sake, we'll use trivial examples.
Concrete real-life cases, as building projects, will be documented in specific sections.

#### Create Project Structure

* Create the root dir of the project or use the _template wrapper project_ mentioned above. 
* At project root, execute `jeka scaffold#run scaffold#wrap` (or just `jekaw scaffold#run` if using the template wrapper project).
* Execute `jeka intellij#iml` or `jeka eclipse#files` in order to generate IDE configuration file. 
* The project with a _Jeka_ structure and a basic build class is ready to work within your IDE

Execute `jeka -h` (or simply `jeka`) to display a contextual help on the console.

### KBeans

_KBean_ is the central concept of execution engine. It consists in classes sharing characteristics :
* Extending `JkBean`
* May declare `public void` methods taking no arguments. All these methods are invokable from command line.
* May declare `public` fields _(aka KBean properties)_. These field values can be injected from command line.
* May override `init` method to perform specific initialisation tasks.
* May override `postInit` method to perform tasks once all KBeans has been initialized.
* They are supposed to be instantiated by the execution engine and not from user code. 
 .

_KBeans_ can be declared in _def_ directory as source file or just be present as classes in classpath (see later).

* KBean methods can be invoked from command line as`jeka [kbeanName]#methoName [kbeanName]#[propertyName]=xxx` or 
from the IDE using a basic `main` method (see later).
* Many methods/properties can be invoked in a single command line.
* _[kbeanName]#_ prefix can be omitted. By default, it will be resolved on the first KBean found in _def_ dir.  

In a given project, there can only be one _KBean_ instance per _KBean_ class, but if you work with a multi-project
build there can be several in classpath (one per project).

Generally _KBeans_ interact with each other inside their `init` method. They access each other using `getRuntime().getRegistry().get(MyBean.class)`.

When a _KBean_ depends on another one, it's good to declare it as an instance property of the first bean as this 
dependency will be mentioned in the quto-generated documentation.

#### Create a Basic KBean

* Create a class extending `JKBean` in _def_ source dir.
* Declare a public field of a simple type (String, boolean, int, float, enum, date, composite objects of simple types).
    It can be declared with a default value (e.g. `public int yourFieldName = 3;`).
* Declare a `public void` method taking no arguments. Implement it in a way it depends on the declared field.
* Execute `jeka yourMethodName yourFiedName=5` on console at root of you project. It runs !

___Extras___
* Annotate class, fields and methods with `@JkDoc` to provide help support.
* Execute `jeka help` to see _KBean_ description in help console. 
* _def_ may contain several classes. They can be helpers or other _KBEANS_. If you want a class not to be compiled, name it with a leading '_'.
* Fields can be annotated with `@JkInjectProperty("my.prop.name")` to inject the value of a _property_ in.
* For more details about accepted field injected types, see `dev.jeka.core.tool.FieldInjector#parse` method.
* _KBean_ properties can also been nested composite objects, see example in `dev.jeka.core.tool.builtins.project.ProjectJkBean#pack` field.

#### 3rd party dependencies

Jeka embeds a bunch of utilities to perform build related tasks (file/zip manipulation, git, launching processes, compilation, testing, dependency management, crypto, ...) 
nevertheless, you may want rightfully to use some 3rd-party dependencies.

* One way is to add directly jar files to _jeka/boot_ directory.
  * Add jar files to _jeka/boot_ directory.
  * Execute `jeka intellij#iml` or `jeka eclipse#files`.
  * Now, you can use added libraries in your code.
* Another way is to annotate your build class with `@JkInjectClasspath` mentioning either a module coordinate (e.g. _org.seleniumhq.selenium:selenium-remote-driver:4.0.0_) or a path on the local file system.
  * Annotate your build class as mentioned.
  * Execute `jeka intellij#iml` or `jeka eclipse#files`.
  * Now, you can use declared libraries along their dependencies in your code.
  * Be aware that a dependencies imported via `@JkInjectClasspath` annotation is imported for all build classes and not only for annotated class.
* The last way is to add it at execution time by mentioning either a module coordinate or a file path in the command line using '@' as in `@my.org:a-jeka-plugin:1.0.0`.
  

#### Import _KBean_ from other Projects

In multi-project build, it's quite common that a _KBean_ accesses to a _KBean_ instance coming from another project. 
You can achieve it in a statically typed way.

* In _master_ _KBean_, declare a field of type `JkBean` (e.g. ´JkBean importedBuild;`). It doesn't have to be public.
* Annotate it with `@JkInjectProject` mentioning the relative path of the imported project (e.g. `@JkInjectProject("../anotherModule")).
* Execute `jeka intellij#iml` or `jeka eclipse#files`.
* Redefine the declared type from `JkBean` to the concrete type of imported _KBean_
* Now, master _KBean_ can access the imported _KBean_ in a static typed way.
* See example [here](https://github.com/jerkar/jeka/blob/master/dev.jeka.master/jeka/def/MasterBuild.java).
* Be careful that the imported _KBean_ deals with file paths using `JkClass#getBaseDir` in order it can be safely executed from any working directory.

#### Launch and Debug from the IDE

There's 2 ways of launching or debugging _Jeka_ builds from IDE. We don't mention here, usage of [Intellij plugin](https://github.com/jerkar/jeka-ide-intellij).

##### Create a `main` Method inside your _def_ Classes

Create one or many main methods as :
```
 public static void main(String[] args) {
        JkInit.instanceOf(CoreBuild.class, args).cleanPack();
    }

    public static class Release {
        public static void main(String[] args) {
            JkInit.instanceOf(MasterBuild.class, args, "-runIT").release();
        }
    }
```
Build classes (inheriting `JkClass`) must be instantiated using `JkInit#instanceOf` in order it be setup in proper state.

The arguments passed in `main` method are interpreted as command line arguments.

Launching or debugging this way is performant as all build classes and their dependencies are already on classpath. Therefore, no compilation or dependency resolution is needed.

Be careful to launch the _main_ method using _module dir_ as _working dir_. On _IntelliJ_, this is not the default (it uses _project dir_).

To change _intelliJ_ defaults, follow : *Edit Configurations | Edit configuration templates... |  Application | Working Directory : $MODULE_DIR$*.

##### Configure an IDE Launcher 

Sometimes, you may need to mimic closer the command line behavior, for debugging purpose or to pass '@' arguments.

* Create an IDE launcher for a Java Application
* Set `dev.jeka.tool.Main` as Java main class.
* Set the same command line arguments as you would do for invoking from command line (Do not include _jeka_ command).

### More about KBeans

When executing, Jeka will first determine the _default KBean_ to instantiate it. The _default KBean_ is 
determined as follows :
1. The _KBean_ mentioned in command line `-kb=` option.
2. The first _KBean_ found in _def_ dir according the fully qualified class name alphabetical order.

The _KBean instantiation_ consists in :
1. Call the constructor
2. Inject properties in _KBean_ fields
3. Call its `init`method.

The `init` method of the _default KBean_ can, in turn, inkove oth

### Properties

Properties are pairs of String  _key-value_ that are used across Jeka system. It typically carries urls, local paths,
tool versions or credentials. They can be globally accessed using `JkProperties#get*` static method.

Properties can be defined at different level, in order of precedence :
* System properties : Properties can be defined using system properties as `-DpropertyName=value`. System properties can
  be injected from Jeka command line.
* OS environment variables : Properties can also be defined as OS environment variable.
* Project : Defined in _[Project Root]/jeka/project.properties_. Used typically for storing tool version (e.g. `jeka.kotlin.version=1.5.21`).
* Global : Defined in _[User Home]/.jeka/global.properties_ file. Used typically to define urls, local paths and credentials.

### Useful commands 

_Jeka_ comes with predefined methods coming either from `JkClass` or built-in plugins. 

* `jeka` : Displays on console methods and options invokable from command line, along plugins available in the classpath.
* `jeka [pugin-name]#help` : Displays on consoles all methods and option invokable for the specified plugin (e.g. `jeka scaffold#help`).
* `jeka intellij#iml` : Generates iml file for Intellij. It is generated according the dependencies declared for this project.
* `jeka intellij#iml -JKC=` : If the above fails cause your def classes do not compile, using `-JKC=` avoids def compilation phase.
* `jeka eclipse#files` : Same purpose as above to generate metadata files for Eclipse.
* `jeka scaffold#run` : Generates files for creating a basic Jeka project from scratch.
* `jeka scaffold#wrap` : Generates wrapper files (jekaw/jekaw.bat and bootstrap jar)
* `jeka scaffold#run java#` : Generate files for creating a Jeka project for building a JVM language project

### Useful standard options

You can add these options to you command line.

* `-kb=[KBeanName]` : By default, Jeka instantiates the first _KBean_ found under _def_ directory to execute methods on. 
  You can force to instantiate a specific class by passing its long or short name. 
  If the class is already in classpath, then no _def_ compilation occurs.
  Using simply `-JKC=` is equivalent to `-JKC=JkClass` which is the base class bundled in Jeka.
* `-lri` : Displays runtime info. This will display on console meaningfull information about current Jeka version, Java version, base directory, download repository, classpath, ...
* `-lsu` : Shows logs about jeka setup (compilation of def classes, plugin loading, ...).These informations are not logged by default.
* `-ls=BRACE` : Alters console output by delimiting tasks with braces and mentioning the processing time for each.
* `-ls=DEBUG` : Alters console output by showing the class name and line number from where the log has been emitted.
* `-lv` : Alters console output by displaying trace logs (emitted by `JkLog#trace`)
* `-dcf` : Force compilation of _def_ classes, even if they are marked as up-to-date.

### How to change the JDK that will run _Jeka_

To determine the JDK to run upon, _jeka_ looks in priority order at :
* _JEKA_JDK_ environment variable ([_JEKA_JDK_]/bin/java must point on _java_ executable)
* _JAVA_HOME_ environment variable 

If none of these variables are present, _jeka_ will run upon the _java_ executable accessible from your _PATH_ environment.

### How to change the repository _Jeka_ uses to fetch dependencies 

By default, _jeka_ fetch dependencies from maven central (https://repo.maven.apache.org/maven2).

You can select another default repository by setting the `jeka.repos.download.url` options. 
We recommend storing this value in your [USER DIR]/.jeka/options.properties file to be reused across projects.

For more details, see `JkRepoFromOptions` javadoc.




## Build Library

TODO

### Examples

TODO
