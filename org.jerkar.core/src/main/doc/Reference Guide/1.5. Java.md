## Java

Jerkar provides API for processing usual Java build tasks. To illustrate this, let's start from the following 
layout : 

```java
    Path src = getBaseDir().resolve("src/main/java");
    Path buildDir = getBaseDir().resolve("build/output");
    Path classDir = getOutputDir().resolve("classes");
    Path jarFile = getOutputDir().resolve("jar/" + getBaseTree().getRoot().getFileName() + ".jar");
    JkClasspath classpath = JkClasspath.of(getBaseTree().andAccept("libs/**/*.jar").getFiles());
    Path reportDir = buildDir.resolve("junitRreport");
```

### Compilation

`JkJavaCompiler` stands for the compiler binary or tool while `JkJavaCompileSpec` stands for what to compile and how.

```java
JkJavaCompiler.ofJdk().compile(JkJavaCompileSpec.of()
                .setOutputDir(classDir)
                .setClasspath(classpath)
                .setSourceAndTargetVersion(JkJavaVersion.V8)
                .addSources(src));
```

`JkJavaCompiler.ofJdk()` provides the compiler embedded with the JDK without forking the process. It is possible to fork 
it or choose an external compiler for cross-compile purpose.


### Javadoc

Simple Javadoc tasks can be performed using `JkJavadocMaker` class.

```java
JkJavadocMaker.of(JkPathTreeSet.of(src), buildDir.resolve("javadoc")).process();
```

### Manifest 

Manifest can be created or update using `JkManifest`.

```java
JkManifest.ofEmpty().addMainClass("org.jerkar.samples.RunClass").writeToStandardLocation(classDir);
```

### Classpath

Jerkar provides `JkClasspath` to construct and reason about classpath.

```java
JkClasspath classpath = JkUrlClassLoader.ofCurrent().getFullClasspath();
Path guavaJar = classpath.getEntryContainingClass("com.google.common.base.Strings");
```
### Java jar 

